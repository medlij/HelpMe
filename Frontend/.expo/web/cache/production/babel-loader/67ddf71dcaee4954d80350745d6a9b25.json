{"ast":null,"code":"import isSelectionValid from\"../../modules/isSelectionValid\";var keyName='__reactResponderId';function getEventPath(domEvent){if(domEvent.type==='selectionchange'){var target=window.getSelection().anchorNode;return composedPathFallback(target);}else{var path=domEvent.composedPath!=null?domEvent.composedPath():composedPathFallback(domEvent.target);return path;}}function composedPathFallback(target){var path=[];while(target!=null&&target!==document.body){path.push(target);target=target.parentNode;}return path;}function getResponderId(node){if(node!=null){return node[keyName];}return null;}export function setResponderId(node,id){if(node!=null){node[keyName]=id;}}export function getResponderPaths(domEvent){var idPath=[];var nodePath=[];var eventPath=getEventPath(domEvent);for(var i=0;i<eventPath.length;i++){var node=eventPath[i];var id=getResponderId(node);if(id!=null){idPath.push(id);nodePath.push(node);}}return{idPath:idPath,nodePath:nodePath};}export function getLowestCommonAncestor(pathA,pathB){var pathALength=pathA.length;var pathBLength=pathB.length;if(pathALength===0||pathBLength===0||pathA[pathALength-1]!==pathB[pathBLength-1]){return null;}var itemA=pathA[0];var indexA=0;var itemB=pathB[0];var indexB=0;if(pathALength-pathBLength>0){indexA=pathALength-pathBLength;itemA=pathA[indexA];pathALength=pathBLength;}if(pathBLength-pathALength>0){indexB=pathBLength-pathALength;itemB=pathB[indexB];pathBLength=pathALength;}var depth=pathALength;while(depth--){if(itemA===itemB){return itemA;}itemA=pathA[indexA++];itemB=pathB[indexB++];}return null;}export function hasTargetTouches(target,touches){if(!touches||touches.length===0){return false;}for(var i=0;i<touches.length;i++){var node=touches[i].target;if(node!=null){if(target.contains(node)){return true;}}}return false;}export function hasValidSelection(domEvent){if(domEvent.type==='selectionchange'){return isSelectionValid();}return domEvent.type==='select';}export function isPrimaryPointerDown(domEvent){var altKey=domEvent.altKey,button=domEvent.button,buttons=domEvent.buttons,ctrlKey=domEvent.ctrlKey,type=domEvent.type;var isTouch=type==='touchstart'||type==='touchmove';var isPrimaryMouseDown=type==='mousedown'&&(button===0||buttons===1);var isPrimaryMouseMove=type==='mousemove'&&buttons===1;var noModifiers=altKey===false&&ctrlKey===false;if(isTouch||isPrimaryMouseDown&&noModifiers||isPrimaryMouseMove&&noModifiers){return true;}return false;}","map":{"version":3,"sources":["/home/fatima/HelpMe/Frontend/node_modules/react-native-web/src/hooks/useResponderEvents/utils.js"],"names":["isSelectionValid","keyName","getEventPath","domEvent","type","target","window","getSelection","anchorNode","composedPathFallback","path","composedPath","document","body","push","parentNode","getResponderId","node","setResponderId","id","getResponderPaths","idPath","nodePath","eventPath","i","length","getLowestCommonAncestor","pathA","pathB","pathALength","pathBLength","itemA","indexA","itemB","indexB","depth","hasTargetTouches","touches","contains","hasValidSelection","isPrimaryPointerDown","altKey","button","buttons","ctrlKey","isTouch","isPrimaryMouseDown","isPrimaryMouseMove","noModifiers"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport isSelectionValid from '../../modules/isSelectionValid';\n\nconst keyName = '__reactResponderId';\n\nfunction getEventPath(domEvent: any): Array<any> {\n  // The 'selectionchange' event always has the 'document' as the target.\n  // Use the anchor node as the initial target to reconstruct a path.\n  // (We actually only need the first \"responder\" node in practice.)\n  if (domEvent.type === 'selectionchange') {\n    const target = window.getSelection().anchorNode;\n    return composedPathFallback(target);\n  } else {\n    const path =\n      domEvent.composedPath != null\n        ? domEvent.composedPath()\n        : composedPathFallback(domEvent.target);\n    return path;\n  }\n}\n\nfunction composedPathFallback(target: any): Array<any> {\n  const path = [];\n  while (target != null && target !== document.body) {\n    path.push(target);\n    target = target.parentNode;\n  }\n  return path;\n}\n\n/**\n * Retrieve the responderId from a host node\n */\nfunction getResponderId(node: any): ?number {\n  if (node != null) {\n    return node[keyName];\n  }\n  return null;\n}\n\n/**\n * Store the responderId on a host node\n */\nexport function setResponderId(node: any, id: number) {\n  if (node != null) {\n    node[keyName] = id;\n  }\n}\n\n/**\n * Filter the event path to contain only the nodes attached to the responder system\n */\nexport function getResponderPaths(\n  domEvent: any\n): {| idPath: Array<number>, nodePath: Array<any> |} {\n  const idPath = [];\n  const nodePath = [];\n  const eventPath = getEventPath(domEvent);\n  for (let i = 0; i < eventPath.length; i++) {\n    const node = eventPath[i];\n    const id = getResponderId(node);\n    if (id != null) {\n      idPath.push(id);\n      nodePath.push(node);\n    }\n  }\n  return { idPath, nodePath };\n}\n\n/**\n * Walk the paths and find the first common ancestor\n */\nexport function getLowestCommonAncestor(pathA: Array<any>, pathB: Array<any>) {\n  let pathALength = pathA.length;\n  let pathBLength = pathB.length;\n  if (\n    // If either path is empty\n    pathALength === 0 ||\n    pathBLength === 0 ||\n    // If the last elements aren't the same there can't be a common ancestor\n    // that is connected to the responder system\n    pathA[pathALength - 1] !== pathB[pathBLength - 1]\n  ) {\n    return null;\n  }\n\n  let itemA = pathA[0];\n  let indexA = 0;\n  let itemB = pathB[0];\n  let indexB = 0;\n\n  // If A is deeper, skip indices that can't match.\n  if (pathALength - pathBLength > 0) {\n    indexA = pathALength - pathBLength;\n    itemA = pathA[indexA];\n    pathALength = pathBLength;\n  }\n\n  // If B is deeper, skip indices that can't match\n  if (pathBLength - pathALength > 0) {\n    indexB = pathBLength - pathALength;\n    itemB = pathB[indexB];\n    pathBLength = pathALength;\n  }\n\n  // Walk in lockstep until a match is found\n  let depth = pathALength;\n  while (depth--) {\n    if (itemA === itemB) {\n      return itemA;\n    }\n    itemA = pathA[indexA++];\n    itemB = pathB[indexB++];\n  }\n  return null;\n}\n\n/**\n * Determine whether any of the active touches are within the current responder.\n * This cannot rely on W3C `targetTouches`, as neither IE11 nor Safari implement it.\n */\nexport function hasTargetTouches(target: any, touches: any): boolean {\n  if (!touches || touches.length === 0) {\n    return false;\n  }\n  for (let i = 0; i < touches.length; i++) {\n    const node = touches[i].target;\n    if (node != null) {\n      if (target.contains(node)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Ignore 'selectionchange' events that don't correspond with a person's intent to\n * select text.\n */\nexport function hasValidSelection(domEvent: any) {\n  if (domEvent.type === 'selectionchange') {\n    return isSelectionValid();\n  }\n  return domEvent.type === 'select';\n}\n\n/**\n * Events are only valid if the primary button was used without specific modifier keys.\n */\nexport function isPrimaryPointerDown(domEvent: any): boolean {\n  const { altKey, button, buttons, ctrlKey, type } = domEvent;\n  const isTouch = type === 'touchstart' || type === 'touchmove';\n  const isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);\n  const isPrimaryMouseMove = type === 'mousemove' && buttons === 1;\n  const noModifiers = altKey === false && ctrlKey === false;\n\n  if (isTouch || (isPrimaryMouseDown && noModifiers) || (isPrimaryMouseMove && noModifiers)) {\n    return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}