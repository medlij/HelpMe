{"ast":null,"code":"function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{CodedError}from'@unimodules/core';var GOOGLE_API_URL='https://maps.googleapis.com/maps/api/geocode/json';var googleApiKey;export function setGoogleApiKey(apiKey){googleApiKey=apiKey;}export function googleGeocodeAsync(address){var result;return _regeneratorRuntime.async(function googleGeocodeAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:assertGoogleApiKey();_context.next=3;return _regeneratorRuntime.awrap(requestGoogleApiAsync({address:address}));case 3:result=_context.sent;if(!(result.status==='ZERO_RESULTS')){_context.next=6;break;}return _context.abrupt(\"return\",[]);case 6:assertGeocodeResults(result);return _context.abrupt(\"return\",result.results.map(geocodingResultToLocation));case 8:case\"end\":return _context.stop();}}},null,null,null,Promise);}export function googleReverseGeocodeAsync(options){var result;return _regeneratorRuntime.async(function googleReverseGeocodeAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:assertGoogleApiKey();_context2.next=3;return _regeneratorRuntime.awrap(requestGoogleApiAsync({latlng:options.latitude+\",\"+options.longitude}));case 3:result=_context2.sent;if(!(result.status==='ZERO_RESULTS')){_context2.next=6;break;}return _context2.abrupt(\"return\",[]);case 6:assertGeocodeResults(result);return _context2.abrupt(\"return\",result.results.map(reverseGeocodingResultToAddress));case 8:case\"end\":return _context2.stop();}}},null,null,null,Promise);}function assertGeocodeResults(resultObject){var status=resultObject.status,error_message=resultObject.error_message;if(status!=='ZERO_RESULTS'&&status!=='OK'){if(error_message){throw new CodedError(status,error_message);}else if(status==='UNKNOWN_ERROR'){throw new CodedError(status,'the request could not be processed due to a server error. The request may succeed if you try again.');}throw new CodedError(status,\"An error occurred during geocoding.\");}}function assertGoogleApiKey(){if(!googleApiKey){throw new Error('Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.');}}function requestGoogleApiAsync(params){var query,result;return _regeneratorRuntime.async(function requestGoogleApiAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:query=Object.entries(params).map(function(entry){return entry[0]+\"=\"+encodeURI(entry[1]);}).join('&');_context3.next=3;return _regeneratorRuntime.awrap(fetch(GOOGLE_API_URL+\"?key=\"+googleApiKey+\"&\"+query));case 3:result=_context3.sent;_context3.next=6;return _regeneratorRuntime.awrap(result.json());case 6:return _context3.abrupt(\"return\",_context3.sent);case 7:case\"end\":return _context3.stop();}}},null,null,null,Promise);}function geocodingResultToLocation(result){var location=result.geometry.location;return{latitude:location.lat,longitude:location.lng};}function reverseGeocodingResultToAddress(result){var address={};for(var _iterator=_createForOfIteratorHelperLoose(result.address_components),_step;!(_step=_iterator()).done;){var _ref=_step.value;var long_name=_ref.long_name;var short_name=_ref.short_name;var types=_ref.types;if(types.includes('locality')){address.city=long_name;continue;}if(types.includes('sublocality')){address.district=long_name;continue;}if(types.includes('street_address')||types.includes('route')){address.street=long_name;continue;}if(types.includes('administrative_area_level_1')){address.region=long_name;continue;}if(types.includes('administrative_area_level_2')){address.subregion=long_name;continue;}if(types.includes('country')){address.country=long_name;address.isoCountryCode=short_name;continue;}if(types.includes('postal_code')){address.postalCode=long_name;continue;}if(types.includes('point_of_interest')){address.name=long_name;continue;}}if(!address.name){address.name=result.formatted_address.replace(/,.*$/,'');}return address;}","map":{"version":3,"sources":["../src/LocationGoogleGeocoding.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodedError } from '@unimodules/core';\n\nimport { LocationGeocodedAddress, LocationGeocodedLocation } from './Location.types';\n\nconst GOOGLE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';\nlet googleApiKey;\n\ntype GoogleApiGeocodingAddressComponent = {\n  long_name: string;\n  short_name: string;\n  types: string[];\n};\n\ntype GoogleApiGeocodingResult = {\n  address_components: GoogleApiGeocodingAddressComponent[];\n  formatted_address: string;\n  geometry: {\n    location: {\n      lat: number;\n      lng: number;\n    };\n  };\n};\n\ntype GoogleApiGeocodingResponse = {\n  results: GoogleApiGeocodingResult[];\n  status: string;\n};\n\nexport function setGoogleApiKey(apiKey: string) {\n  googleApiKey = apiKey;\n}\n\nexport async function googleGeocodeAsync(address: string): Promise<LocationGeocodedLocation[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({ address });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(geocodingResultToLocation);\n}\n\nexport async function googleReverseGeocodeAsync(options: {\n  latitude: number;\n  longitude: number;\n}): Promise<LocationGeocodedAddress[]> {\n  assertGoogleApiKey();\n\n  const result = await requestGoogleApiAsync({\n    latlng: `${options.latitude},${options.longitude}`,\n  });\n\n  if (result.status === 'ZERO_RESULTS') {\n    return [];\n  }\n  assertGeocodeResults(result);\n  return result.results.map(reverseGeocodingResultToAddress);\n}\n\n// https://developers.google.com/maps/documentation/geocoding/intro\nfunction assertGeocodeResults(resultObject: any): void {\n  const { status, error_message } = resultObject;\n  if (status !== 'ZERO_RESULTS' && status !== 'OK') {\n    if (error_message) {\n      throw new CodedError(status, error_message);\n    } else if (status === 'UNKNOWN_ERROR') {\n      throw new CodedError(\n        status,\n        'the request could not be processed due to a server error. The request may succeed if you try again.'\n      );\n    }\n    throw new CodedError(status, `An error occurred during geocoding.`);\n  }\n}\n\n/**\n * Makes sure the Google API key is set.\n */\nfunction assertGoogleApiKey() {\n  if (!googleApiKey) {\n    throw new Error(\n      'Google API key is required to use geocoding. Please set it using `setGoogleApiKey` method.'\n    );\n  }\n}\n\n/**\n * Generic and handy method for sending requests to Google Maps API endpoint.\n */\nasync function requestGoogleApiAsync(\n  params: { address: string } | { latlng: string }\n): Promise<GoogleApiGeocodingResponse> {\n  const query = Object.entries(params)\n    .map(entry => `${entry[0]}=${encodeURI(entry[1])}`)\n    .join('&');\n  const result = await fetch(`${GOOGLE_API_URL}?key=${googleApiKey}&${query}`);\n  return await result.json();\n}\n\n/**\n * Converts Google's result to the location object.\n */\nfunction geocodingResultToLocation(result: GoogleApiGeocodingResult): LocationGeocodedLocation {\n  const { location } = result.geometry;\n  return {\n    latitude: location.lat,\n    longitude: location.lng,\n  };\n}\n\n/**\n * Converts Google's result to address object.\n */\nfunction reverseGeocodingResultToAddress(\n  result: GoogleApiGeocodingResult\n): LocationGeocodedAddress {\n  const address: Partial<LocationGeocodedAddress> = {};\n\n  for (const { long_name, short_name, types } of result.address_components) {\n    if (types.includes('locality')) {\n      address.city = long_name;\n      continue;\n    }\n    if (types.includes('sublocality')) {\n      address.district = long_name;\n      continue;\n    }\n    if (types.includes('street_address') || types.includes('route')) {\n      address.street = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_1')) {\n      address.region = long_name;\n      continue;\n    }\n    if (types.includes('administrative_area_level_2')) {\n      address.subregion = long_name;\n      continue;\n    }\n    if (types.includes('country')) {\n      address.country = long_name;\n      address.isoCountryCode = short_name;\n      continue;\n    }\n    if (types.includes('postal_code')) {\n      address.postalCode = long_name;\n      continue;\n    }\n    if (types.includes('point_of_interest')) {\n      address.name = long_name;\n      continue;\n    }\n  }\n  if (!address.name) {\n    address.name = result.formatted_address.replace(/,.*$/, '');\n  }\n  return address as LocationGeocodedAddress;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}