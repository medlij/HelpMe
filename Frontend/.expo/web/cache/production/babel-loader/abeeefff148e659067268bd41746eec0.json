{"ast":null,"code":"import{canUseDOM}from'fbjs/lib/ExecutionEnvironment';import createResponderEvent from\"./createResponderEvent\";import{isCancelish,isEndish,isMoveish,isScroll,isSelectionChange,isStartish}from\"./ResponderEventTypes\";import{getLowestCommonAncestor,getResponderPaths,hasTargetTouches,hasValidSelection,isPrimaryPointerDown,setResponderId}from\"./utils\";import ResponderTouchHistoryStore from\"./ResponderTouchHistoryStore\";var emptyObject={};var startRegistration=['onStartShouldSetResponderCapture','onStartShouldSetResponder',{bubbles:true}];var moveRegistration=['onMoveShouldSetResponderCapture','onMoveShouldSetResponder',{bubbles:true}];var scrollRegistration=['onScrollShouldSetResponderCapture','onScrollShouldSetResponder',{bubbles:false}];var shouldSetResponderEvents={touchstart:startRegistration,mousedown:startRegistration,touchmove:moveRegistration,mousemove:moveRegistration,scroll:scrollRegistration};var emptyResponder={id:null,idPath:null,node:null};var responderListenersMap=new Map();var isEmulatingMouseEvents=false;var trackedTouchCount=0;var currentResponder={id:null,node:null,idPath:null};function changeCurrentResponder(responder){currentResponder=responder;}function getResponderConfig(id){var config=responderListenersMap.get(id);return config!=null?config:emptyObject;}function eventListener(domEvent){var eventType=domEvent.type;var eventTarget=domEvent.target;if(eventType==='touchstart'){isEmulatingMouseEvents=true;}if(eventType==='touchmove'||trackedTouchCount>1){isEmulatingMouseEvents=false;}if(eventType==='mousedown'&&isEmulatingMouseEvents||eventType==='mousemove'&&isEmulatingMouseEvents||eventType==='mousemove'&&trackedTouchCount<1){return;}if(isEmulatingMouseEvents&&eventType==='mouseup'){if(trackedTouchCount===0){isEmulatingMouseEvents=false;}return;}var isStartEvent=isStartish(eventType)&&isPrimaryPointerDown(domEvent);var isMoveEvent=isMoveish(eventType);var isEndEvent=isEndish(eventType);var isScrollEvent=isScroll(eventType);var isSelectionChangeEvent=isSelectionChange(eventType);var responderEvent=createResponderEvent(domEvent);if(isStartEvent||isMoveEvent||isEndEvent){if(domEvent.touches){trackedTouchCount=domEvent.touches.length;}else{if(isStartEvent){trackedTouchCount=1;}else if(isEndEvent){trackedTouchCount=0;}}ResponderTouchHistoryStore.recordTouchTrack(eventType,responderEvent.nativeEvent);}var eventPaths=getResponderPaths(domEvent);var wasNegotiated=false;var wantsResponder;if(isStartEvent||isMoveEvent||isScrollEvent&&trackedTouchCount>0){var currentResponderIdPath=currentResponder.idPath;var eventIdPath=eventPaths.idPath;if(currentResponderIdPath!=null&&eventIdPath!=null){var lowestCommonAncestor=getLowestCommonAncestor(currentResponderIdPath,eventIdPath);if(lowestCommonAncestor!=null){var indexOfLowestCommonAncestor=eventIdPath.indexOf(lowestCommonAncestor);var index=indexOfLowestCommonAncestor+(lowestCommonAncestor===currentResponder.id?1:0);eventPaths={idPath:eventIdPath.slice(index),nodePath:eventPaths.nodePath.slice(index)};}else{eventPaths=null;}}if(eventPaths!=null){wantsResponder=findWantsResponder(eventPaths,domEvent,responderEvent);if(wantsResponder!=null){attemptTransfer(responderEvent,wantsResponder);wasNegotiated=true;}}}if(currentResponder.id!=null&&currentResponder.node!=null){var _currentResponder=currentResponder,id=_currentResponder.id,node=_currentResponder.node;var _getResponderConfig=getResponderConfig(id),onResponderStart=_getResponderConfig.onResponderStart,onResponderMove=_getResponderConfig.onResponderMove,onResponderEnd=_getResponderConfig.onResponderEnd,onResponderRelease=_getResponderConfig.onResponderRelease,onResponderTerminate=_getResponderConfig.onResponderTerminate,onResponderTerminationRequest=_getResponderConfig.onResponderTerminationRequest;responderEvent.bubbles=false;responderEvent.cancelable=false;responderEvent.currentTarget=node;if(isStartEvent){if(onResponderStart!=null){onResponderStart(responderEvent);}}else if(isMoveEvent){if(onResponderMove!=null){onResponderMove(responderEvent);}}else{var isTerminateEvent=isCancelish(eventType)||eventType==='contextmenu'||eventType==='blur'&&eventTarget===window||eventType==='blur'&&eventTarget.contains(node)&&domEvent.relatedTarget!==node||isScrollEvent&&trackedTouchCount===0||isScrollEvent&&eventTarget.contains(node)&&eventTarget!==node||isSelectionChangeEvent&&hasValidSelection(domEvent);var isReleaseEvent=isEndEvent&&!isTerminateEvent&&!hasTargetTouches(node,domEvent.touches);if(isEndEvent){if(onResponderEnd!=null){onResponderEnd(responderEvent);}}if(isReleaseEvent){if(onResponderRelease!=null){onResponderRelease(responderEvent);}changeCurrentResponder(emptyResponder);}if(isTerminateEvent){var shouldTerminate=true;if(eventType==='contextmenu'||eventType==='scroll'||eventType==='selectionchange'){if(wasNegotiated||onResponderTerminationRequest!=null&&onResponderTerminationRequest(responderEvent)===false){shouldTerminate=false;}}if(shouldTerminate){if(onResponderTerminate!=null){onResponderTerminate(responderEvent);}changeCurrentResponder(emptyResponder);isEmulatingMouseEvents=false;trackedTouchCount=0;}}}}}function findWantsResponder(eventPaths,domEvent,responderEvent){var shouldSetCallbacks=shouldSetResponderEvents[domEvent.type];if(shouldSetCallbacks!=null){var idPath=eventPaths.idPath,nodePath=eventPaths.nodePath;var shouldSetCallbackCaptureName=shouldSetCallbacks[0];var shouldSetCallbackBubbleName=shouldSetCallbacks[1];var bubbles=shouldSetCallbacks[2].bubbles;var check=function check(id,node,callbackName){var config=getResponderConfig(id);var shouldSetCallback=config[callbackName];if(shouldSetCallback!=null){if(shouldSetCallback(responderEvent)===true){return{id:id,node:node,idPath:idPath};}}};for(var i=idPath.length-1;i>=0;i--){var id=idPath[i];var node=nodePath[i];var result=check(id,node,shouldSetCallbackCaptureName);if(result!=null){return result;}if(responderEvent.isPropagationStopped()===true){return;}}if(bubbles){for(var _i=0;_i<idPath.length;_i++){var _id=idPath[_i];var _node=nodePath[_i];var _result=check(_id,_node,shouldSetCallbackBubbleName);if(_result!=null){return _result;}if(responderEvent.isPropagationStopped()===true){return;}}}else{var _id2=idPath[0];var _node2=nodePath[0];var target=domEvent.target;if(target===_node2){return check(_id2,_node2,shouldSetCallbackBubbleName);}}}}function attemptTransfer(responderEvent,wantsResponder){var _currentResponder2=currentResponder,currentId=_currentResponder2.id,currentNode=_currentResponder2.node;var id=wantsResponder.id,node=wantsResponder.node;var _getResponderConfig2=getResponderConfig(id),onResponderGrant=_getResponderConfig2.onResponderGrant,onResponderReject=_getResponderConfig2.onResponderReject;responderEvent.bubbles=false;responderEvent.cancelable=false;responderEvent.currentTarget=node;if(currentId==null){if(onResponderGrant!=null){responderEvent.currentTarget=node;responderEvent.dispatchConfig.registrationName='onResponderGrant';onResponderGrant(responderEvent);}changeCurrentResponder(wantsResponder);}else{var _getResponderConfig3=getResponderConfig(currentId),onResponderTerminate=_getResponderConfig3.onResponderTerminate,onResponderTerminationRequest=_getResponderConfig3.onResponderTerminationRequest;var allowTransfer=onResponderTerminationRequest!=null&&onResponderTerminationRequest(responderEvent);if(allowTransfer){if(onResponderTerminate!=null){responderEvent.currentTarget=currentNode;onResponderTerminate(responderEvent);}if(onResponderGrant!=null){onResponderGrant(responderEvent);}changeCurrentResponder(wantsResponder);}else{if(onResponderReject!=null){onResponderReject(responderEvent);}}}}var documentEventsCapturePhase=['blur','scroll'];var documentEventsBubblePhase=['mousedown','mousemove','mouseup','dragstart','touchstart','touchmove','touchend','touchcancel','contextmenu','select','selectionchange'];export function attachListeners(){if(canUseDOM&&window.__reactResponderSystemActive==null){window.addEventListener('blur',eventListener);documentEventsBubblePhase.forEach(function(eventType){document.addEventListener(eventType,eventListener);});documentEventsCapturePhase.forEach(function(eventType){document.addEventListener(eventType,eventListener,true);});window.__reactResponderSystemActive=true;}}export function addNode(id,node,config){setResponderId(node,id);responderListenersMap.set(id,config);}export function removeNode(id){if(currentResponder.id===id){terminateResponder();}if(responderListenersMap.has(id)){responderListenersMap.delete(id);}}export function terminateResponder(){var _currentResponder3=currentResponder,id=_currentResponder3.id,node=_currentResponder3.node;if(id!=null&&node!=null){var _getResponderConfig4=getResponderConfig(id),onResponderTerminate=_getResponderConfig4.onResponderTerminate;if(onResponderTerminate!=null){var event=createResponderEvent({});event.currentTarget=node;onResponderTerminate(event);}changeCurrentResponder(emptyResponder);}isEmulatingMouseEvents=false;trackedTouchCount=0;}export function getResponderNode(){return currentResponder.node;}","map":{"version":3,"sources":["/home/fatima/HelpMe/Frontend/node_modules/react-native-web/src/hooks/useResponderEvents/ResponderSystem.js"],"names":["canUseDOM","createResponderEvent","isCancelish","isEndish","isMoveish","isScroll","isSelectionChange","isStartish","getLowestCommonAncestor","getResponderPaths","hasTargetTouches","hasValidSelection","isPrimaryPointerDown","setResponderId","ResponderTouchHistoryStore","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isMoveEvent","isEndEvent","isScrollEvent","isSelectionChangeEvent","responderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","isTerminateEvent","window","contains","relatedTarget","isReleaseEvent","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","i","result","isPropagationStopped","currentId","currentNode","onResponderGrant","onResponderReject","dispatchConfig","registrationName","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","attachListeners","__reactResponderSystemActive","addEventListener","forEach","document","addNode","set","removeNode","terminateResponder","has","delete","event","getResponderNode"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\nimport type { ResponderEvent } from './createResponderEvent';\n\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nimport createResponderEvent from './createResponderEvent';\nimport {\n  isCancelish,\n  isEndish,\n  isMoveish,\n  isScroll,\n  isSelectionChange,\n  isStartish\n} from './ResponderEventTypes';\nimport {\n  getLowestCommonAncestor,\n  getResponderPaths,\n  hasTargetTouches,\n  hasValidSelection,\n  isPrimaryPointerDown,\n  setResponderId\n} from './utils';\nimport ResponderTouchHistoryStore from './ResponderTouchHistoryStore';\n\n/* ------------ TYPES ------------ */\n\ntype ResponderId = number;\n\ntype ActiveResponderInstance = {\n  id: ResponderId,\n  idPath: Array<number>,\n  node: any\n};\n\ntype EmptyResponderInstance = {\n  id: null,\n  idPath: null,\n  node: null\n};\n\ntype ResponderInstance = ActiveResponderInstance | EmptyResponderInstance;\n\nexport type ResponderConfig = {\n  // Direct responder events dispatched directly to responder. Do not bubble.\n  onResponderEnd?: ?(e: ResponderEvent) => void,\n  onResponderGrant?: ?(e: ResponderEvent) => void,\n  onResponderMove?: ?(e: ResponderEvent) => void,\n  onResponderRelease?: ?(e: ResponderEvent) => void,\n  onResponderReject?: ?(e: ResponderEvent) => void,\n  onResponderStart?: ?(e: ResponderEvent) => void,\n  onResponderTerminate?: ?(e: ResponderEvent) => void,\n  onResponderTerminationRequest?: ?(e: ResponderEvent) => boolean,\n  // On pointer down, should this element become the responder?\n  onStartShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onStartShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On pointer move, should this element become the responder?\n  onMoveShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onMoveShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On scroll, should this element become the responder? Do no bubble\n  onScrollShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onScrollShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean,\n  // On text selection change, should this element become the responder?\n  onSelectionChangeShouldSetResponder?: ?(e: ResponderEvent) => boolean,\n  onSelectionChangeShouldSetResponderCapture?: ?(e: ResponderEvent) => boolean\n};\n\nconst emptyObject = {};\n\n/* ------------ IMPLEMENTATION ------------ */\n\nconst startRegistration = [\n  'onStartShouldSetResponderCapture',\n  'onStartShouldSetResponder',\n  { bubbles: true }\n];\nconst moveRegistration = [\n  'onMoveShouldSetResponderCapture',\n  'onMoveShouldSetResponder',\n  { bubbles: true }\n];\nconst scrollRegistration = [\n  'onScrollShouldSetResponderCapture',\n  'onScrollShouldSetResponder',\n  { bubbles: false }\n];\nconst shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\n\nconst emptyResponder = { id: null, idPath: null, node: null };\nconst responderListenersMap = new Map();\n\nlet isEmulatingMouseEvents = false;\nlet trackedTouchCount = 0;\nlet currentResponder: ResponderInstance = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder: ResponderInstance) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id: ResponderId): ResponderConfig | Object {\n  const config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\nfunction eventListener(domEvent: any) {\n  const eventType = domEvent.type;\n  const eventTarget = domEvent.target;\n\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n\n  // Flag when browser may produce emulated events\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  }\n  // Remove flag when browser will not produce emulated events\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  }\n  // Ignore various events in particular circumstances\n  if (\n    // Ignore browser emulated mouse events\n    (eventType === 'mousedown' && isEmulatingMouseEvents) ||\n    (eventType === 'mousemove' && isEmulatingMouseEvents) ||\n    // Ignore mousemove if a mousedown didn't occur first\n    (eventType === 'mousemove' && trackedTouchCount < 1)\n  ) {\n    return;\n  }\n  // Remove flag after emulated events are finished\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n    return;\n  }\n\n  const isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);\n  const isMoveEvent = isMoveish(eventType);\n  const isEndEvent = isEndish(eventType);\n  const isScrollEvent = isScroll(eventType);\n  const isSelectionChangeEvent = isSelectionChange(eventType);\n  const responderEvent = createResponderEvent(domEvent);\n\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n    ResponderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n\n  /**\n   * Responder System logic\n   */\n\n  let eventPaths = getResponderPaths(domEvent);\n  let wasNegotiated = false;\n  let wantsResponder;\n\n  // If an event occured that might change the current responder...\n  if (isStartEvent || isMoveEvent || (isScrollEvent && trackedTouchCount > 0)) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    const currentResponderIdPath = currentResponder.idPath;\n    const eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      const lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);\n      if (lowestCommonAncestor != null) {\n        const indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);\n        // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n        const index =\n          indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  }\n\n  // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n  if (currentResponder.id != null && currentResponder.node != null) {\n    const { id, node } = currentResponder;\n    const {\n      onResponderStart,\n      onResponderMove,\n      onResponderEnd,\n      onResponderRelease,\n      onResponderTerminate,\n      onResponderTerminationRequest\n    } = getResponderConfig(id);\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node;\n\n    // Start\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        onResponderStart(responderEvent);\n      }\n    }\n    // Move\n    else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        onResponderMove(responderEvent);\n      }\n    } else {\n      const isTerminateEvent =\n        isCancelish(eventType) ||\n        // native context menu\n        eventType === 'contextmenu' ||\n        // window blur\n        (eventType === 'blur' && eventTarget === window) ||\n        // responder (or ancestors) blur\n        (eventType === 'blur' && (eventTarget.contains(node) && domEvent.relatedTarget !== node)) ||\n        // native scroll without using a pointer\n        (isScrollEvent && trackedTouchCount === 0) ||\n        // native scroll on node that is parent of the responder (allow siblings to scroll)\n        (isScrollEvent && eventTarget.contains(node) && eventTarget !== node) ||\n        // native select/selectionchange on node\n        (isSelectionChangeEvent && hasValidSelection(domEvent));\n\n      const isReleaseEvent =\n        isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);\n\n      // End\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          onResponderEnd(responderEvent);\n        }\n      }\n      // Release\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          onResponderRelease(responderEvent);\n        }\n        changeCurrentResponder(emptyResponder);\n      }\n      // Terminate\n      if (isTerminateEvent) {\n        let shouldTerminate = true;\n\n        // Responders can still avoid termination but only for these events.\n        if (\n          eventType === 'contextmenu' ||\n          eventType === 'scroll' ||\n          eventType === 'selectionchange'\n        ) {\n          if (\n            wasNegotiated ||\n            // Only call this function is it wasn't already called during negotiation.\n            (onResponderTerminationRequest != null &&\n              onResponderTerminationRequest(responderEvent) === false)\n          ) {\n            shouldTerminate = false;\n          }\n        }\n\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            onResponderTerminate(responderEvent);\n          }\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  const shouldSetCallbacks = shouldSetResponderEvents[(domEvent.type: any)]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    const { idPath, nodePath } = eventPaths;\n\n    const shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    const shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    const { bubbles } = shouldSetCallbacks[2];\n\n    const check = function(id, node, callbackName) {\n      const config = getResponderConfig(id);\n      const shouldSetCallback = config[callbackName];\n      if (shouldSetCallback != null) {\n        if (shouldSetCallback(responderEvent) === true) {\n          return { id, node, idPath };\n        }\n      }\n    };\n\n    // capture\n    for (let i = idPath.length - 1; i >= 0; i--) {\n      const id = idPath[i];\n      const node = nodePath[i];\n      const result = check(id, node, shouldSetCallbackCaptureName);\n      if (result != null) {\n        return result;\n      }\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    }\n\n    // bubble\n    if (bubbles) {\n      for (let i = 0; i < idPath.length; i++) {\n        const id = idPath[i];\n        const node = nodePath[i];\n        const result = check(id, node, shouldSetCallbackBubbleName);\n        if (result != null) {\n          return result;\n        }\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      const id = idPath[0];\n      const node = nodePath[0];\n      const target = domEvent.target;\n      if (target === node) {\n        return check(id, node, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n\n/**\n * Attempt to transfer the responder.\n */\nfunction attemptTransfer(responderEvent: ResponderEvent, wantsResponder: ActiveResponderInstance) {\n  const { id: currentId, node: currentNode } = currentResponder;\n  const { id, node } = wantsResponder;\n\n  const { onResponderGrant, onResponderReject } = getResponderConfig(id);\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node;\n  // Set responder\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n    changeCurrentResponder(wantsResponder);\n  }\n  // Negotiate with current responder\n  else {\n    const { onResponderTerminate, onResponderTerminationRequest } = getResponderConfig(currentId);\n    const allowTransfer =\n      onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent);\n    if (allowTransfer) {\n      // Terminate existing responder\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        onResponderTerminate(responderEvent);\n      }\n      // Grant next responder\n      if (onResponderGrant != null) {\n        onResponderGrant(responderEvent);\n      }\n      changeCurrentResponder(wantsResponder);\n    } else {\n      // Reject responder request\n      if (onResponderReject != null) {\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\nconst documentEventsCapturePhase = ['blur', 'scroll'];\nconst documentEventsBubblePhase = [\n  // mouse\n  'mousedown',\n  'mousemove',\n  'mouseup',\n  'dragstart',\n  // touch\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'touchcancel',\n  // other\n  'contextmenu',\n  'select',\n  'selectionchange'\n];\nexport function attachListeners() {\n  if (canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(eventType => {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n\n/**\n * Register a node with the ResponderSystem.\n */\nexport function addNode(id: ResponderId, node: any, config: ResponderConfig) {\n  setResponderId(node, id);\n  responderListenersMap.set(id, config);\n}\n\n/**\n * Unregister a node with the ResponderSystem.\n */\nexport function removeNode(id: ResponderId) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\nexport function terminateResponder() {\n  const { id, node } = currentResponder;\n  if (id != null && node != null) {\n    const { onResponderTerminate } = getResponderConfig(id);\n    if (onResponderTerminate != null) {\n      const event = createResponderEvent({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n    changeCurrentResponder(emptyResponder);\n  }\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\nexport function getResponderNode(): any {\n  return currentResponder.node;\n}\n"]},"metadata":{},"sourceType":"module"}