{"ast":null,"code":"var slice=Array.prototype.slice;export default function createOrderedCSSStyleSheet(sheet){var groups={};var selectors={};if(sheet!=null){var group;slice.call(sheet.cssRules).forEach(function(cssRule,i){var cssText=cssRule.cssText;if(cssText.indexOf('stylesheet-group')>-1){group=decodeGroupRule(cssRule);groups[group]={start:i,rules:[cssText]};}else{var selectorText=getSelectorText(cssText);if(selectorText!=null){selectors[selectorText]=true;groups[group].rules.push(cssText);}}});}function sheetInsert(sheet,group,text){var orderedGroups=getOrderedGroups(groups);var groupIndex=orderedGroups.indexOf(group);var nextGroupIndex=groupIndex+1;var nextGroup=orderedGroups[nextGroupIndex];var position=nextGroup!=null&&groups[nextGroup].start!=null?groups[nextGroup].start:sheet.cssRules.length;var isInserted=insertRuleAt(sheet,text,position);if(isInserted){if(groups[group].start==null){groups[group].start=position;}for(var i=nextGroupIndex;i<orderedGroups.length;i+=1){var groupNumber=orderedGroups[i];var previousStart=groups[groupNumber].start;groups[groupNumber].start=previousStart+1;}}return isInserted;}var OrderedCSSStyleSheet={getTextContent:function getTextContent(){return getOrderedGroups(groups).map(function(group){var rules=groups[group].rules;return rules.join('\\n');}).join('\\n');},insert:function insert(cssText,groupValue){var group=Number(groupValue);if(groups[group]==null){var markerRule=encodeGroupRule(group);groups[group]={start:null,rules:[markerRule]};if(sheet!=null){sheetInsert(sheet,group,markerRule);}}var selectorText=getSelectorText(cssText);if(selectorText!=null&&selectors[selectorText]==null){selectors[selectorText]=true;groups[group].rules.push(cssText);if(sheet!=null){var isInserted=sheetInsert(sheet,group,cssText);if(!isInserted){groups[group].rules.pop();}}}}};return OrderedCSSStyleSheet;}function encodeGroupRule(group){return\"[stylesheet-group=\\\"\"+group+\"\\\"]{}\";}function decodeGroupRule(cssRule){return Number(cssRule.selectorText.split(/[\"']/)[1]);}function getOrderedGroups(obj){return Object.keys(obj).map(Number).sort(function(a,b){return a>b?1:-1;});}var pattern=/\\s*([,])\\s*/g;function getSelectorText(cssText){var selector=cssText.split('{')[0].trim();return selector!==''?selector.replace(pattern,'$1'):null;}function insertRuleAt(root,cssText,position){try{root.insertRule(cssText,position);return true;}catch(e){return false;}}","map":{"version":3,"sources":["/home/fatima/HelpMe/Frontend/node_modules/react-native-web/src/exports/StyleSheet/createOrderedCSSStyleSheet.js"],"names":["slice","Array","prototype","createOrderedCSSStyleSheet","sheet","groups","selectors","group","call","cssRules","forEach","cssRule","i","cssText","indexOf","decodeGroupRule","start","rules","selectorText","getSelectorText","push","sheetInsert","text","orderedGroups","getOrderedGroups","groupIndex","nextGroupIndex","nextGroup","position","length","isInserted","insertRuleAt","groupNumber","previousStart","OrderedCSSStyleSheet","getTextContent","map","join","insert","groupValue","Number","markerRule","encodeGroupRule","pop","split","obj","Object","keys","sort","a","b","pattern","selector","trim","replace","root","insertRule","e"],"mappings":"AAYA,GAAMA,CAAAA,KAAK,CAAGC,KAAK,CAACC,SAAN,CAAgBF,KAA9B,CAiBA,cAAe,SAASG,CAAAA,0BAAT,CAAoCC,KAApC,CAA2D,CACxE,GAAMC,CAAAA,MAAc,CAAG,EAAvB,CACA,GAAMC,CAAAA,SAAoB,CAAG,EAA7B,CAKA,GAAIF,KAAK,EAAI,IAAb,CAAmB,CACjB,GAAIG,CAAAA,KAAJ,CACAP,KAAK,CAACQ,IAAN,CAAWJ,KAAK,CAACK,QAAjB,EAA2BC,OAA3B,CAAmC,SAACC,OAAD,CAAUC,CAAV,CAAgB,CACjD,GAAMC,CAAAA,OAAO,CAAGF,OAAO,CAACE,OAAxB,CAEA,GAAIA,OAAO,CAACC,OAAR,CAAgB,kBAAhB,EAAsC,CAAC,CAA3C,CAA8C,CAC5CP,KAAK,CAAGQ,eAAe,CAACJ,OAAD,CAAvB,CACAN,MAAM,CAACE,KAAD,CAAN,CAAgB,CAAES,KAAK,CAAEJ,CAAT,CAAYK,KAAK,CAAE,CAACJ,OAAD,CAAnB,CAAhB,CACD,CAHD,IAGO,CACL,GAAMK,CAAAA,YAAY,CAAGC,eAAe,CAACN,OAAD,CAApC,CACA,GAAIK,YAAY,EAAI,IAApB,CAA0B,CACxBZ,SAAS,CAACY,YAAD,CAAT,CAA0B,IAA1B,CACAb,MAAM,CAACE,KAAD,CAAN,CAAcU,KAAd,CAAoBG,IAApB,CAAyBP,OAAzB,EACD,CACF,CACF,CAbD,EAcD,CAED,QAASQ,CAAAA,WAAT,CAAqBjB,KAArB,CAA4BG,KAA5B,CAAmCe,IAAnC,CAAyC,CACvC,GAAMC,CAAAA,aAAa,CAAGC,gBAAgB,CAACnB,MAAD,CAAtC,CACA,GAAMoB,CAAAA,UAAU,CAAGF,aAAa,CAACT,OAAd,CAAsBP,KAAtB,CAAnB,CACA,GAAMmB,CAAAA,cAAc,CAAGD,UAAU,CAAG,CAApC,CACA,GAAME,CAAAA,SAAS,CAAGJ,aAAa,CAACG,cAAD,CAA/B,CAEA,GAAME,CAAAA,QAAQ,CACZD,SAAS,EAAI,IAAb,EAAqBtB,MAAM,CAACsB,SAAD,CAAN,CAAkBX,KAAlB,EAA2B,IAAhD,CACIX,MAAM,CAACsB,SAAD,CAAN,CAAkBX,KADtB,CAEIZ,KAAK,CAACK,QAAN,CAAeoB,MAHrB,CAIA,GAAMC,CAAAA,UAAU,CAAGC,YAAY,CAAC3B,KAAD,CAAQkB,IAAR,CAAcM,QAAd,CAA/B,CAEA,GAAIE,UAAJ,CAAgB,CAEd,GAAIzB,MAAM,CAACE,KAAD,CAAN,CAAcS,KAAd,EAAuB,IAA3B,CAAiC,CAC/BX,MAAM,CAACE,KAAD,CAAN,CAAcS,KAAd,CAAsBY,QAAtB,CACD,CAED,IAAK,GAAIhB,CAAAA,CAAC,CAAGc,cAAb,CAA6Bd,CAAC,CAAGW,aAAa,CAACM,MAA/C,CAAuDjB,CAAC,EAAI,CAA5D,CAA+D,CAC7D,GAAMoB,CAAAA,WAAW,CAAGT,aAAa,CAACX,CAAD,CAAjC,CACA,GAAMqB,CAAAA,aAAa,CAAG5B,MAAM,CAAC2B,WAAD,CAAN,CAAoBhB,KAA1C,CACAX,MAAM,CAAC2B,WAAD,CAAN,CAAoBhB,KAApB,CAA4BiB,aAAa,CAAG,CAA5C,CACD,CACF,CAED,MAAOH,CAAAA,UAAP,CACD,CAED,GAAMI,CAAAA,oBAAoB,CAAG,CAI3BC,cAJ2B,0BAIF,CACvB,MAAOX,CAAAA,gBAAgB,CAACnB,MAAD,CAAhB,CACJ+B,GADI,CACA,SAAA7B,KAAK,CAAI,CACZ,GAAMU,CAAAA,KAAK,CAAGZ,MAAM,CAACE,KAAD,CAAN,CAAcU,KAA5B,CACA,MAAOA,CAAAA,KAAK,CAACoB,IAAN,CAAW,IAAX,CAAP,CACD,CAJI,EAKJA,IALI,CAKC,IALD,CAAP,CAMD,CAX0B,CAgB3BC,MAhB2B,iBAgBpBzB,OAhBoB,CAgBH0B,UAhBG,CAgBiB,CAC1C,GAAMhC,CAAAA,KAAK,CAAGiC,MAAM,CAACD,UAAD,CAApB,CAGA,GAAIlC,MAAM,CAACE,KAAD,CAAN,EAAiB,IAArB,CAA2B,CACzB,GAAMkC,CAAAA,UAAU,CAAGC,eAAe,CAACnC,KAAD,CAAlC,CAEAF,MAAM,CAACE,KAAD,CAAN,CAAgB,CAAES,KAAK,CAAE,IAAT,CAAeC,KAAK,CAAE,CAACwB,UAAD,CAAtB,CAAhB,CAEA,GAAIrC,KAAK,EAAI,IAAb,CAAmB,CACjBiB,WAAW,CAACjB,KAAD,CAAQG,KAAR,CAAekC,UAAf,CAAX,CACD,CACF,CAKD,GAAMvB,CAAAA,YAAY,CAAGC,eAAe,CAACN,OAAD,CAApC,CACA,GAAIK,YAAY,EAAI,IAAhB,EAAwBZ,SAAS,CAACY,YAAD,CAAT,EAA2B,IAAvD,CAA6D,CAE3DZ,SAAS,CAACY,YAAD,CAAT,CAA0B,IAA1B,CACAb,MAAM,CAACE,KAAD,CAAN,CAAcU,KAAd,CAAoBG,IAApB,CAAyBP,OAAzB,EAEA,GAAIT,KAAK,EAAI,IAAb,CAAmB,CACjB,GAAM0B,CAAAA,UAAU,CAAGT,WAAW,CAACjB,KAAD,CAAQG,KAAR,CAAeM,OAAf,CAA9B,CACA,GAAI,CAACiB,UAAL,CAAiB,CAGfzB,MAAM,CAACE,KAAD,CAAN,CAAcU,KAAd,CAAoB0B,GAApB,GACD,CACF,CACF,CACF,CAhD0B,CAA7B,CAmDA,MAAOT,CAAAA,oBAAP,CACD,CAMD,QAASQ,CAAAA,eAAT,CAAyBnC,KAAzB,CAAgC,CAC9B,6BAA6BA,KAA7B,SACD,CAED,QAASQ,CAAAA,eAAT,CAAyBJ,OAAzB,CAAkC,CAChC,MAAO6B,CAAAA,MAAM,CAAC7B,OAAO,CAACO,YAAR,CAAqB0B,KAArB,CAA2B,MAA3B,EAAmC,CAAnC,CAAD,CAAb,CACD,CAED,QAASpB,CAAAA,gBAAT,CAA0BqB,GAA1B,CAAuD,CACrD,MAAOC,CAAAA,MAAM,CAACC,IAAP,CAAYF,GAAZ,EACJT,GADI,CACAI,MADA,EAEJQ,IAFI,CAEC,SAACC,CAAD,CAAIC,CAAJ,QAAWD,CAAAA,CAAC,CAAGC,CAAJ,CAAQ,CAAR,CAAY,CAAC,CAAxB,EAFD,CAAP,CAGD,CAED,GAAMC,CAAAA,OAAO,CAAG,cAAhB,CACA,QAAShC,CAAAA,eAAT,CAAyBN,OAAzB,CAAkC,CAChC,GAAMuC,CAAAA,QAAQ,CAAGvC,OAAO,CAAC+B,KAAR,CAAc,GAAd,EAAmB,CAAnB,EAAsBS,IAAtB,EAAjB,CACA,MAAOD,CAAAA,QAAQ,GAAK,EAAb,CAAkBA,QAAQ,CAACE,OAAT,CAAiBH,OAAjB,CAA0B,IAA1B,CAAlB,CAAoD,IAA3D,CACD,CAED,QAASpB,CAAAA,YAAT,CAAsBwB,IAAtB,CAA4B1C,OAA5B,CAA6Ce,QAA7C,CAAwE,CACtE,GAAI,CAEF2B,IAAI,CAACC,UAAL,CAAgB3C,OAAhB,CAAyBe,QAAzB,EACA,MAAO,KAAP,CACD,CAAC,MAAO6B,CAAP,CAAU,CAGV,MAAO,MAAP,CACD,CACF","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n */\n\ntype Groups = { [key: number]: { start: ?number, rules: Array<string> } };\ntype Selectors = { [key: string]: boolean };\n\nconst slice = Array.prototype.slice;\n\n/**\n * Order-based insertion of CSS.\n *\n * Each rule is associated with a numerically defined group.\n * Groups are ordered within the style sheet according to their number, with the\n * lowest first.\n *\n * Groups are implemented using marker rules. The selector of the first rule of\n * each group is used only to encode the group number for hydration. An\n * alternative implementation could rely on CSSMediaRule, allowing groups to be\n * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is\n * broken.\n * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule\n * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674\n */\nexport default function createOrderedCSSStyleSheet(sheet: ?CSSStyleSheet) {\n  const groups: Groups = {};\n  const selectors: Selectors = {};\n\n  /**\n   * Hydrate approximate record from any existing rules in the sheet.\n   */\n  if (sheet != null) {\n    let group;\n    slice.call(sheet.cssRules).forEach((cssRule, i) => {\n      const cssText = cssRule.cssText;\n      // Create record of existing selectors and rules\n      if (cssText.indexOf('stylesheet-group') > -1) {\n        group = decodeGroupRule(cssRule);\n        groups[group] = { start: i, rules: [cssText] };\n      } else {\n        const selectorText = getSelectorText(cssText);\n        if (selectorText != null) {\n          selectors[selectorText] = true;\n          groups[group].rules.push(cssText);\n        }\n      }\n    });\n  }\n\n  function sheetInsert(sheet, group, text) {\n    const orderedGroups = getOrderedGroups(groups);\n    const groupIndex = orderedGroups.indexOf(group);\n    const nextGroupIndex = groupIndex + 1;\n    const nextGroup = orderedGroups[nextGroupIndex];\n    // Insert rule before the next group, or at the end of the stylesheet\n    const position =\n      nextGroup != null && groups[nextGroup].start != null\n        ? groups[nextGroup].start\n        : sheet.cssRules.length;\n    const isInserted = insertRuleAt(sheet, text, position);\n\n    if (isInserted) {\n      // Set the starting index of the new group\n      if (groups[group].start == null) {\n        groups[group].start = position;\n      }\n      // Increment the starting index of all subsequent groups\n      for (let i = nextGroupIndex; i < orderedGroups.length; i += 1) {\n        const groupNumber = orderedGroups[i];\n        const previousStart = groups[groupNumber].start;\n        groups[groupNumber].start = previousStart + 1;\n      }\n    }\n\n    return isInserted;\n  }\n\n  const OrderedCSSStyleSheet = {\n    /**\n     * The textContent of the style sheet.\n     */\n    getTextContent(): string {\n      return getOrderedGroups(groups)\n        .map(group => {\n          const rules = groups[group].rules;\n          return rules.join('\\n');\n        })\n        .join('\\n');\n    },\n\n    /**\n     * Insert a rule into the style sheet\n     */\n    insert(cssText: string, groupValue: number) {\n      const group = Number(groupValue);\n\n      // Create a new group.\n      if (groups[group] == null) {\n        const markerRule = encodeGroupRule(group);\n        // Create the internal record.\n        groups[group] = { start: null, rules: [markerRule] };\n        // Update CSSOM.\n        if (sheet != null) {\n          sheetInsert(sheet, group, markerRule);\n        }\n      }\n\n      // selectorText is more reliable than cssText for insertion checks. The\n      // browser excludes vendor-prefixed properties and rewrites certain values\n      // making cssText more likely to be different from what was inserted.\n      const selectorText = getSelectorText(cssText);\n      if (selectorText != null && selectors[selectorText] == null) {\n        // Update the internal records.\n        selectors[selectorText] = true;\n        groups[group].rules.push(cssText);\n        // Update CSSOM.\n        if (sheet != null) {\n          const isInserted = sheetInsert(sheet, group, cssText);\n          if (!isInserted) {\n            // Revert internal record change if a rule was rejected (e.g.,\n            // unrecognized pseudo-selector)\n            groups[group].rules.pop();\n          }\n        }\n      }\n    }\n  };\n\n  return OrderedCSSStyleSheet;\n}\n\n/**\n * Helper functions\n */\n\nfunction encodeGroupRule(group) {\n  return `[stylesheet-group=\"${group}\"]{}`;\n}\n\nfunction decodeGroupRule(cssRule) {\n  return Number(cssRule.selectorText.split(/[\"']/)[1]);\n}\n\nfunction getOrderedGroups(obj: { [key: number]: any }) {\n  return Object.keys(obj)\n    .map(Number)\n    .sort((a, b) => (a > b ? 1 : -1));\n}\n\nconst pattern = /\\s*([,])\\s*/g;\nfunction getSelectorText(cssText) {\n  const selector = cssText.split('{')[0].trim();\n  return selector !== '' ? selector.replace(pattern, '$1') : null;\n}\n\nfunction insertRuleAt(root, cssText: string, position: number): boolean {\n  try {\n    // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.\n    root.insertRule(cssText, position);\n    return true;\n  } catch (e) {\n    // JSDOM doesn't support `CSSSMediaRule#insertRule`.\n    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}